#include "imageinfos.h"
#include "sequenceinteractor.h"


QMap<QString, CommonColorCode> ImageInfos::_platename_to_colorCode;
QMap<QString, QList<ImageInfos*> > ImageInfos::_platename_to_infos;

//QMutex platenameProtect;

ImageInfos::ImageInfos(SequenceInteractor *par, QString fname, QString platename):
    _parent(par),
    _name(fname),
    _plate(platename),
    _modified(true)
{
    _platename_to_infos[platename] << this;
}

ImageInfos::~ImageInfos()
{
    _platename_to_infos[_plate].removeAll(this);
}




cv::Mat &ImageInfos::image()
{
<<<<<<< HEAD

=======
>>>>>>> master
  QMutexLocker lock(&_lockImage);

  if (_image.empty())
    {
      _image = cv::imread(_name.toStdString(), 2);

      if (_image.type() != CV_16U)
        {
          cv::Mat t;
          _image.convertTo(t, CV_16U);
          _image = t;
        }

      float min  = _platename_to_colorCode[_plate].min;
      float max = _platename_to_colorCode[_plate].max;
      for (int i = 0; i < _image.rows; ++i)
        for (int j = 0; j < _image.cols; ++j)
          {
            unsigned int v = _image.at<unsigned short>(i,j);
            if (v < min) min = v;
            else if ( v > max) max = v;
          }

          _platename_to_colorCode[_plate].min = std::min(min, _platename_to_colorCode[_plate].min);
          _platename_to_colorCode[_plate].max = std::max(max, _platename_to_colorCode[_plate].max );
          // FIXME: Should it be a global parameter ?
          if (_platename_to_colorCode[_plate]._dispMax == -std::numeric_limits<float>::infinity())
            _platename_to_colorCode[_plate]._dispMax = _platename_to_colorCode[_plate].max;
          if (_platename_to_colorCode[_plate]._dispMin == std::numeric_limits<float>::infinity())
            _platename_to_colorCode[_plate]._dispMin = _platename_to_colorCode[_plate].min;
    }

//  _modified = false;
  return _image;
}

QColor ImageInfos::getColor()
{
  return QColor::fromRgb(_platename_to_colorCode[_plate]._r,_platename_to_colorCode[_plate]._g,_platename_to_colorCode[_plate]._b);
}

void ImageInfos::setDefaultColor(int channel)
{
  channel --;
  _modified = true;
  setColor(255,255,255); // Default to white

  if (channel == 0) setColor(255,0,0);
  if (channel == 1) setColor(0,255,0);
  if (channel == 2) setColor(0,0,255);
  if (channel == 3) setColor(255,0,255);
  if (channel == 4) setColor(255,255,0);
  if (channel == 5) setColor(0,255,255);

}

void ImageInfos::rangeChanged(double mi, double ma)
{
  _modified = true;
//  qDebug() << "Image infos " << mi << ma;
  _platename_to_colorCode[_plate]._dispMin = mi;
  _platename_to_colorCode[_plate]._dispMax = ma;

  int i = 0;
  foreach (ImageInfos* ifo, _platename_to_infos[_plate])
  {
      //   qDebug() << ++i;
      ifo->_parent->modifiedImage();

  }
//  foreach (CoreImage* ci, _parent->) {

//  }

}

<<<<<<< HEAD
=======



>>>>>>> master
void ImageInfos::forceMinValue(double val)
{
  _modified = true;
//  qDebug() << "Image infos " << mi << ma;
  _platename_to_colorCode[_plate].min = val;

  int i = 0;
  foreach (ImageInfos* ifo, _platename_to_infos[_plate])
  {
      //   qDebug() << ++i;
      ifo->_parent->modifiedImage();

  }
}

void ImageInfos::forceMaxValue(double val)
{
  _modified = true;
//  qDebug() << "Image infos " << mi << ma;
  _platename_to_colorCode[_plate].max = val;

  int i = 0;
  foreach (ImageInfos* ifo, _platename_to_infos[_plate])
  {
      //   qDebug() << ++i;
      ifo->_parent->modifiedImage();

  }
}

void ImageInfos::rangeMinValueChanged(double mi)
{
  _modified = true;
//  qDebug() << "Image infos " << mi << ma;
  _platename_to_colorCode[_plate]._dispMin = mi;

  int i = 0;
  foreach (ImageInfos* ifo, _platename_to_infos[_plate])
  {
      //   qDebug() << ++i;
      ifo->_parent->modifiedImage();

  }
}

void ImageInfos::rangeMaxValueChanged(double ma)
{
  _modified = true;
//  qDebug() << "Image infos " << mi << ma;
  _platename_to_colorCode[_plate]._dispMax = ma;

  int i = 0;
  foreach (ImageInfos* ifo, _platename_to_infos[_plate])
  {
      //   qDebug() << ++i;
      ifo->_parent->modifiedImage();

  }
}

void ImageInfos::setActive(bool value)
{
   _modified = true;
  _platename_to_colorCode[_plate]._active = value;
  foreach (ImageInfos* ifo, _platename_to_infos[_plate])
       ifo->_parent->modifiedImage();
}

void ImageInfos::setColor(QColor c)
{
  _modified = true;
//  qDebug() << "Setting color" <<  c;
  c.setHsv(c.hsvHue(), c.hsvSaturation(), 255);

  _platename_to_colorCode[_plate]._r = c.red();
  _platename_to_colorCode[_plate]._g = c.green();
  _platename_to_colorCode[_plate]._b = c.blue();

  foreach (ImageInfos* ifo, _platename_to_infos[_plate])
       ifo->_parent->modifiedImage();
}
